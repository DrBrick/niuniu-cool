<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ฅ՞•ﻌ•՞ฅ要抱抱</title>
    <link>http://niuniu.langchao2020.tech/</link>
    <description>Recent content on ฅ՞•ﻌ•՞ฅ要抱抱</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>牛牛ฅ^•ﻌ•^ฅ</copyright>
    <lastBuildDate>Fri, 02 Oct 2020 19:10:59 +0800</lastBuildDate><atom:link href="http://niuniu.langchao2020.tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>浅谈SQL语句的执行顺序</title>
      <link>http://niuniu.langchao2020.tech/posts/sql-execution-sequence/</link>
      <pubDate>Fri, 02 Oct 2020 19:10:59 +0800</pubDate>
      
      <guid>http://niuniu.langchao2020.tech/posts/sql-execution-sequence/</guid>
      <description>浅谈SQL语句的执行顺序 一、SQL语句执行顺序解析 SQL语句和编程语言的语句有很大的不同，有一点原因在于SQL并不一定是按照你写的SQL语句顺序执行的。因此在写SQL语句的时候很容易出现问题，最主要的问题还是记不住SQL命令，死记硬背效果好像也不是很好。
需要知道的是，在SQL语句执行的过程中，都会产生一个虚拟表，用来保存SQL语句的执行结果。这些虚拟表对用户来说是透明的，只有最后一步生成的虚拟表才会返回给用户。如果没有再查询中指定某一子句，则将跳过相应的步骤。下面先给出SQL语句的执行顺序，并加以简单的解释。
7) select 8) distinct &amp;lt;select_list&amp;gt; 1) from &amp;lt;left_table&amp;gt; 3) &amp;lt;join_type&amp;gt; join &amp;lt;right_table&amp;gt; 2) on &amp;lt;join_condition&amp;gt; 4) where &amp;lt;where_condition&amp;gt; 5) group by &amp;lt;group_by_list&amp;gt; 6) having &amp;lt;having_condition&amp;gt; 9) order by &amp;lt;order_by_list&amp;gt; 10) limit &amp;lt;limit_number&amp;gt; 1）from：对FROM子句中的左表&amp;lt;left_table&amp;gt;和右表&amp;lt;right_table&amp;gt;执行笛卡儿积（Cartesian product），产生虚拟表VT1。
2）on： 对虚拟表VT1应用ON筛选，只有那些符合&amp;lt;join_condition&amp;gt;的行才被插入虚拟表VT2中。
3）join：如果指定了OUTER JOIN（如LEFT OUTER JOIN、RIGHT OUTERJOIN），那么保留表中未匹配的行作为外部行添加到虚拟表VT2中，产生虚拟表VT3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1）～步骤3），直到处理完所有的表为止。
 这里出现了两个陌生的名词：“保留表”、“外部行”。
LEFT OUTER JOIN把左表记为保留表，RIGHT OUTER JOIN把右表记为保留表&amp;hellip;
一时半会也解释不清这个东西，我自己懂了就好了，先挖个坑，日后再补上具体数据来做详细解释说明。
 4）where：对虚拟表VT3应用WHERE过滤条件，只有符合&amp;lt;where_condition&amp;gt;的记录才被插入虚拟表VT4中。
5）group by：根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5。
6）having：对虚拟表VT6应用HAVING过滤器，只有符合&amp;lt;having_condition&amp;gt;的记录才被插入虚拟表VT6中。
7）select：选择指定的列，插入到虚拟表V7中。
 看到没有，select到第7步才被执行，所以千万别人认为写在第一行的就是第一个被执行的。
 8）distinct：去除重复数据，产生虚拟表V8。
9）order by：将虚拟表V8中的记录按照&amp;lt;order_by_list&amp;gt;进行排序操作，产生虚拟表V9。
 ORDER BY 默认是升序排序，如果要指定为降序排序则需要加上 DESC 修饰。</description>
    </item>
    
    <item>
      <title>Hive认识我的第一天</title>
      <link>http://niuniu.langchao2020.tech/posts/hive-meeting/</link>
      <pubDate>Thu, 01 Oct 2020 17:08:58 +0800</pubDate>
      
      <guid>http://niuniu.langchao2020.tech/posts/hive-meeting/</guid>
      <description>一、Hive简介 1.1 什么是Hive Hive官网给出的定义是：“The Apache Hive ™ data warehouse software facilitates reading, writing, and managing large datasets residing in distributed storage using SQL. Structure can be projected onto data already in storage. A command line tool and JDBC driver are provided to connect users to Hive.”
我粗糙的理解是，Hive是一个类似Hadoop（集群）的客户端，所谓客户端在手天下我有。就好比你拿到了电视的遥控器，想怎么操作电视就怎么操作电视，比如换台。实际上Hive使用的是类似SQL的语句去操作（离线数据分析、数据管理&amp;hellip;）HDFS上的数据，本质是将SQL语句转化成MapReduce作业。
1.2 为什么要使用Hive Hive的本质是将SQL转化成MapReduce作业，那么直接使用MapReduce不就好了，何必转一个弯呢？因为Hive更方便啊，它是遥控器！MapReduce编程模型还是有一定门槛的，代码量多而且只有map和reduce过程，实现复杂的计算逻辑则难度相当之大。
而，Hive能够使得不会编程的数据开发人员也具备操作分析HDFS上数据的能力，只要你SQL写的好、写的妙。
1.3 Hive有什么特点 先说缺点，这样记得更牢固。
首先，慢，而且不是一般的慢。当然这是对少量数据而言，比如查询十多行的数据需要100秒左右的时间，这哪能忍。
其次，Hive不太支持记录级别的增删改操作。注意是不太支持，你要是真想用还是可以用的，只是要选择对应的Hive版本。
最后，Hive不支持事务。它主要是用来做OLAP（联机分析处理）的，而传统数据库是用来做OLTP（联机事务处理）的，这也是它俩的本质区别之一。
优点，我是记不住，正经人谁记某个东西的优点啊。
首先，延展性好。传统SQL能做的它也能做，传统SQL不能做的它还是能做。比如Hive支持自定义函数UDF，开发人员可以根据自己的需求来实现自定义函数。
其次，拥有HDFS的优点。HDFS的优点也算是它的优点，比如横向扩展。比如加机器的时候是不会对Hive造成影响的，连重启服务也不需要。
最后，良好的容错性。这一点是硬凑的，我理解不到这一层。
稍微总结一下：Hive只适合用来做海量数据离线统计分析，也是数据仓库实现常用的技术之一。
二、Hive的架构  用户接口：包括CLI、JDBC等方式（也就是客户端） 元数据MetaStore：Hive通常将元数据信息保存在传统关系型数据库中，如MySQL，但默认是放在Derby数据库中（这种数据库不支持多用户同时访问）。元数据信息包括：库名、表名、表所属的库名、表的列名/分区字段，表的属性（是否为外部表）、表中数据所在的HDFS目录等信息。【由此可见，元数据的重要性不言而喻。】 Driver：包括：解释器、编译器、优化器、执行器。Hive SQL语句从词法分析、语法分析、编译、优化以及查询计划生成，查询计划存储在HDFS上，MapReduce负责调用执行；  解释器：将用户输入的Hive SQL转化成抽象语法树（AST） 编译器：将AST编译成逻辑执行计划 优化器：将逻辑执行计划进行优化 执行器：优化后的逻辑执行计划转换成可以运行的物理执行计划    三、Hive中数据组织方式 3.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://niuniu.langchao2020.tech/about/</link>
      <pubDate>Thu, 01 Oct 2020 00:52:18 +0800</pubDate>
      
      <guid>http://niuniu.langchao2020.tech/about/</guid>
      <description>人的一生中，真正属于自己的财富只有两个：自己的“才华”和自己的“时间”。通常才华越来越多而时间越来越少。人生就是用时间换取才华。</description>
    </item>
    
  </channel>
</rss>
